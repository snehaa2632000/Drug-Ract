# -*- coding: utf-8 -*-
"""FINAL PA PACKAGE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zzm0dNeL-SlNAG0bcK1T1jMPGaM6yvBb

## ***DRUG INTERACTION PREDICTION***

Drug interactions can be structured as graphs. Here we do link prediction to predict the possibility of links between unconnected node pairs in the dataset
"""

import pandas as pd


from google.colab import drive
drive.mount('/content/drive')

#adjacency matrix - drug interaction
interaction_matrix = pd.read_csv('/content/drive/My Drive/drug_matrix.csv')
interaction_matrix.head()

chem_sim=pd.read_csv("https://raw.githubusercontent.com/zw9977129/drug-drug-interaction/master/dataset/chem_Jacarrd_sim.csv")
chem_sim.head()

target=pd.read_csv("https://raw.githubusercontent.com/zw9977129/drug-drug-interaction/master/dataset/target_Jacarrd_sim.csv")
target.head()

transporter=pd.read_csv("https://raw.githubusercontent.com/zw9977129/drug-drug-interaction/master/dataset/transporter_Jacarrd_sim.csv")
transporter.head()

"""NETWORK GRAPH FOR ADJACENCY MATRIX

Each property of the drugs is catogorized in to communities using the GREEDY MODULARITY COMMUNITY
"""

import pandas as pd
import networkx as nx
ad=interaction_matrix.iloc[:,1:]
G = nx.Graph(ad.values)

nx.draw(G,node_size=5)

"""LINKS FOR A PARTICULAR DRUG"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import networkx.algorithms.community as nxcom

adjacency_matrix=interaction_matrix.iloc[5:6,1:]
rows, cols = np.where(adjacency_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
gr = nx.Graph()
gr.add_edges_from(edges)
nx.draw(gr, node_size=5)
plt.show()

"""**EDGE LIST**

Here, the features are the edges in the graph and the target variable is whether a link exists between them or not.
Target variable can take either 0 or 1
"""

edgelist=nx.generate_edgelist(G)
el=sorted(edgelist)
print(len(el))

"""**DATASET PREPARATION FOR MODEL BUILDING**

RETRIEVING UNCONNECTED NODE PAIRS
"""

adjacency_matrix=interaction_matrix.iloc[:,1:]
adjacency_matrix.shape

adjacency_matrix=adjacency_matrix.to_numpy()
#print(adjacency_matrix.dtype)
#print(adjacency_matrix[0][100],adjacency_matrix[100][0])


unconnected_pairs=[]
connected_pairs=[]
i=0
j=0

for i in range(adjacency_matrix.shape[0]):
  for j in range(i+1):
    if adjacency_matrix[i][j]==0:
      unconnected_pairs.append([i,j])
    else:
      connected_pairs.append([i,j])

print(len(unconnected_pairs))
print(len(connected_pairs))

#unlinked df (data) --->  dataframe of  node pairs which are not connected
node1_unlinked = [i[0] for i in unconnected_pairs]
node2_unlinked = [i[1] for i in unconnected_pairs]

data = pd.DataFrame({'node1':node1_unlinked,'node2':node2_unlinked})

# add target variable 'link'
data['link'] = 0

print(data)

#linked df (graph_data) --->  dataframe of node pairs which are connected

node1_linked = [i[0] for i in connected_pairs]
node2_linked = [i[1] for i in connected_pairs]

graph_data = pd.DataFrame({'node1':node1_linked,'node2':node2_linked})

print(graph_data)

"""POSITIVE SAMPLES (REMOVING LINKS)

Removing existing links and building a model. Later, compare the predicted model with the original model for finding accuracy.
"""

import pandas as pd
import networkx as nx
import tqdm

ad=interaction_matrix.iloc[:,1:]
G = nx.Graph(ad.values)

initial_node_count=len(G.nodes)
temp_data=graph_data.copy()

#list of the indices of the edge pairs whose links are omitted
omissible_links_index=[]

#avoid removing any edge which produces an isolated node or an isolated network

for i in range(adjacency_matrix.shape[0]):
  # remove a node pair and build a new graph
  G_temp = nx.from_pandas_edgelist(temp_data.drop(index = i), "node1", "node2", create_using=nx.Graph())
  
  # check there is no spliting of graph and number of nodes is same
  if (nx.number_connected_components(G_temp) == 1) and (len(G_temp.nodes) == initial_node_count):
    omissible_links_index.append(i)
    temp_data = temp_data.drop(index = i)

len(omissible_links_index)

"""DATA FOR MODEL TRAINING"""

#do not run multiple times as it keeps appending to the list repeatedly
#now append the omissible links to the unlinked nodepair dataframe
#we have both unlinked and linked nodepairs in the dataframe data

graph_data_ghost=graph_data.loc[omissible_links_index]
graph_data_ghost['link']=1

data=data.append(graph_data_ghost[['node1','node2','link']],ignore_index=True)

data['link'].value_counts()

"""FEATURE EXTRACTION"""

#removing removable edges
#new_graph_data is the data after removing the osmissible links from graph_data

partial_data=graph_data.drop(index=graph_data_ghost.index.values)

new_graph_data=nx.from_pandas_edgelist(partial_data,'node1','node2',create_using=nx.Graph())
print(partial_data)

"""TRAINING NODE2VEC MODEL"""

pip install node2vec

from node2vec import Node2Vec
node2vec=Node2Vec(new_graph_data,dimensions=100,walk_length=16,num_walks=50)
n2w_model=node2vec.fit(window=7,min_count=1)

x=[(n2w_model[str(i)]+n2w_model[str(j)]) for i,j in zip(data['node1'], data['node2'])]

"""BUILDING PREDICTION MODEL"""

from sklearn.model_selection import train_test_split

Xtrain,Xtest,ytrain,ytest=train_test_split(np.array(x),data['link'],test_size=0.3,random_state=35)

print(ytest)

"""## FITTING LOGISTIC REGRESSION MODEL"""

from sklearn.linear_model import LogisticRegression

lr=LogisticRegression(class_weight="balanced",max_iter=100000)
lmodel=lr.fit(Xtrain,ytrain)

#prediction using logistic regression model
np.set_printoptions(threshold=np.inf)

prediction=lr.predict_proba(Xtest)

ypred=lmodel.predict(Xtest)
print(ypred)

#MODEL PERFORMANCE
#AUC-ROC score
from sklearn.metrics import roc_auc_score
roc_auc_score(ytest,prediction[:,1])

#Accuracy
from sklearn.metrics import accuracy_score
accuracy=accuracy_score(ypred,ytest)

from sklearn.metrics import classification_report 

print("\n ACCURACY: " , accuracy, "\n")

print("\nCLASSIFICATION REPORT: \n")
print(classification_report(ytest,ypred))

from sklearn.metrics import confusion_matrix
import seaborn as sns

cm=confusion_matrix(ytest,ypred)

cm_df=pd.DataFrame(cm,index=[0,1],
                   columns=[0,1])

sns.heatmap(cm_df,annot=True)

plt.title("ACCURACY")
plt.xlabel("Predicted label")
plt.ylabel("Actual label")
plt.show()

"""## COMPLEX MODEL - LIGHT GBM"""

import lightgbm as lgbm

train_data = lgbm.Dataset(Xtrain, ytrain)
test_data = lgbm.Dataset(Xtest, ytest)

# define parameters
parameters = { 'objective': 'binary','metric': 'auc','is_unbalance': 'true',
              'feature_fraction': 0.5,'bagging_fraction': 0.5,'bagging_freq': 20,
              'num_threads' : 2,'seed' : 76 }

# train lightGBM model
model = lgbm.train(parameters, train_data, valid_sets=test_data,
                   num_boost_round=1000, early_stopping_rounds=50)

#prediction using Light GBM model
ypred=model.predict(Xtest)

for i in range(len(ypred)):
  if ypred[i]>0.5:
    ypred[i]=1
  else:
    ypred[i]=0

print(ypred)

#Accuracy
from sklearn.metrics import accuracy_score
accuracy=accuracy_score(ypred,ytest)
print("Accuracy: ",accuracy)

"""Here, the logistic regression model performed better than LGBM

NETWORK ANALYSIS
  --

For the TRANSPORTING PROPERTY
"""

adj_matrix = transporter.iloc[1:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
gr = nx.Graph()
gr.add_edges_from(edges)
nx.draw(gr, node_size = 7)
plt.show()


communities = sorted(nxcom.greedy_modularity_communities(gr))
# to print the no. of communities
print(f"The transpoter network graph has {len(communities)} communities")

def set_node_community(G, communities):
  for c, v_c in enumerate(communities):
    for v in v_c:
      # Add 1 to save 0 for external edges
      G.nodes[v]['community'] = c + 1

def set_edge_community(G):
  '''Find internal edges and add their community to their attributes'''
  for v, w, in G.edges:
    if G.nodes[v]['community'] == G.nodes[w]['community']:
      # Internal edge, mark with community
      G.edges[v, w]['community'] = G.nodes[v]['community']
    else:
      # External edge, mark as 0
      G.edges[v, w]['community'] = 0

def get_color(i, r_off=1, g_off=1, b_off=1):
  '''Assign a color to a vertex.'''
  r0, g0, b0 = 0, 0, 0
  n = 16
  low, high = 0.1, 0.9
  span = high - low
  r = low + span * (((i + r_off) * 3) % n) / (n - 1)
  g = low + span * (((i + g_off) * 5) % n) / (n - 1)
  b = low + span * (((i + b_off) * 7) % n) / (n - 1)
  return (r, g, b)            

set_node_community(gr, communities)
set_edge_community(gr)

node_color = [get_color(gr.nodes[v]['community']) for v in gr.nodes]

# Set community color for edges between members of the same community (internal) and intra-community edges (external)
external = [(v, w) for v, w in gr.edges if gr.edges[v, w]['community'] == 0]
internal = [(v, w) for v, w in gr.edges if gr.edges[v, w]['community'] > 0]
internal_color = ['black' for e in internal]

graph_pos = nx.spring_layout(gr)

plt.rcParams.update({'figure.figsize': (15, 10)})
# Draw external edges
nx.draw_networkx(gr,pos=graph_pos,node_size=0,edgelist=external,edge_color="silver")

# Draw nodes and internal edges
nx.draw_networkx(gr,pos=graph_pos,node_color=node_color,edgelist=internal,
edge_color=internal_color)

# The following graph shows that the transporter data has a total of 5 communities (the similarity of the drugs on the basis of transporting property of the drugs)
# This can be seen from the network graph where the nodes represnt the drug ID's given by the DrugBank. 
# The analysis shows that the drugs belong broadly to just 2 communities denoted by the green and blue nodes.

"""For the Chemical Similarity Property"""

adj_matrix = chem_sim.iloc[1:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
gr = nx.Graph()
gr.add_edges_from(edges)
#nx.draw(gr, node_size = 7)
#plt.show()

#nx.draw_random(gr, node_size = 7)
#plt.show()

nx.draw_circular(gr, node_size = 7)
plt.show()

communities = sorted(nxcom.greedy_modularity_communities(gr))
# to print the no. of communities
print(f"The Chemical Similarity network graph has {len(communities)} communities")

def set_node_community(G, communities):
  for c, v_c in enumerate(communities):
    for v in v_c:
      # Add 1 to save 0 for external edges
      G.nodes[v]['community'] = c + 1

def set_edge_community(G):
  '''Find internal edges and add their community to their attributes'''
  for v, w, in G.edges:
    if G.nodes[v]['community'] == G.nodes[w]['community']:
      # Internal edge, mark with community
      G.edges[v, w]['community'] = G.nodes[v]['community']
    else:
      # External edge, mark as 0
      G.edges[v, w]['community'] = 0

def get_color(i, r_off=1, g_off=1, b_off=1):
  '''Assign a color to a vertex.'''
  r0, g0, b0 = 0, 0, 0
  n = 16
  low, high = 0.1, 0.9
  span = high - low
  r = low + span * (((i + r_off) * 3) % n) / (n - 1)
  g = low + span * (((i + g_off) * 5) % n) / (n - 1)
  b = low + span * (((i + b_off) * 7) % n) / (n - 1)
  return (r, g, b)            

set_node_community(gr, communities)
set_edge_community(gr)

node_color = [get_color(gr.nodes[v]['community']) for v in gr.nodes]

# Set community color for edges between members of the same community (internal) and intra-community edges (external)
external = [(v, w) for v, w in gr.edges if gr.edges[v, w]['community'] == 0]
internal = [(v, w) for v, w in gr.edges if gr.edges[v, w]['community'] > 0]
internal_color = ['black' for e in internal]

graph_pos = nx.spring_layout(gr)

plt.rcParams.update({'figure.figsize': (15, 10)})
# Draw external edges
nx.draw_networkx(gr,pos=graph_pos,node_size=0,edgelist=external,edge_color="silver")

# Draw nodes and internal edges
nx.draw_networkx(gr,pos=graph_pos,node_color=node_color,edgelist=internal,
edge_color=internal_color)

# On the basis of the Chemical Similarity the drugs are classified into 25 different communities. This analysis shows that there are only 3 major catogory to which
# most of the drugs belong to.

"""For the Target of the Drugs"""

adj_matrix = target.iloc[1:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
gr = nx.Graph()
gr.add_edges_from(edges)
#nx.draw(gr, node_size = 7)
#plt.show()

nx.draw_random(gr, node_size = 7)
plt.show()

nx.draw_circular(gr, node_size = 7)
plt.show()

communities = sorted(nxcom.greedy_modularity_communities(gr))
# to print the no. of communities
print(f"The target network graph has {len(communities)} communities")

def set_node_community(G, communities):
  for c, v_c in enumerate(communities):
    for v in v_c:
      # Add 1 to save 0 for external edges
      G.nodes[v]['community'] = c + 1

def set_edge_community(G):
  '''Find internal edges and add their community to their attributes'''
  for v, w, in G.edges:
    if G.nodes[v]['community'] == G.nodes[w]['community']:
      # Internal edge, mark with community
      G.edges[v, w]['community'] = G.nodes[v]['community']
    else:
      # External edge, mark as 0
      G.edges[v, w]['community'] = 0

def get_color(i, r_off=1, g_off=1, b_off=1):
  '''Assign a color to a vertex.'''
  r0, g0, b0 = 0, 0, 0
  n = 16
  low, high = 0.1, 0.9
  span = high - low
  r = low + span * (((i + r_off) * 3) % n) / (n - 1)
  g = low + span * (((i + g_off) * 5) % n) / (n - 1)
  b = low + span * (((i + b_off) * 7) % n) / (n - 1)
  return (r, g, b)            

set_node_community(gr, communities)
set_edge_community(gr)

node_color = [get_color(gr.nodes[v]['community']) for v in gr.nodes]

# Set community color for edges between members of the same community (internal) and intra-community edges (external)
external = [(v, w) for v, w in gr.edges if gr.edges[v, w]['community'] == 0]
internal = [(v, w) for v, w in gr.edges if gr.edges[v, w]['community'] > 0]
internal_color = ['black' for e in internal]

graph_pos = nx.spring_layout(gr)

plt.rcParams.update({'figure.figsize': (15, 10)})
# Draw external edges
nx.draw_networkx(gr,pos=graph_pos,node_size=0,edgelist=external,edge_color="silver")

# Draw nodes and internal edges
nx.draw_networkx(gr,pos=graph_pos,node_color=node_color,edgelist=internal,
edge_color=internal_color)

# This analysis shows that there are a total of 14 communities.

"""QUANTITATIVE ANALYSIS
  --

Finding the Centrality
"""

import matplotlib
import matplotlib.colors as mcolors
from collections import Counter

print('-------------------------------------------TRANSPORTER--------------------------------------------------------------')
adj_matrix_trans = transporter.iloc[1:,1:]
rows, cols = np.where(adj_matrix_trans == 1)
edges = zip(rows.tolist(), cols.tolist())
gr_trans = nx.Graph()
gr_trans.add_edges_from(edges)

dict_degree = nx.degree_centrality(gr_trans)
dict_closeness = nx.closeness_centrality(gr_trans)
dict_eigenvector = nx.eigenvector_centrality(gr_trans)

print('Top 10 values of degree of centrality',dict(Counter(dict_degree).most_common(10)))
#dict(Counter(dict_colseness).most_common(10))
print('Top 10 values of eigenvector centrality',dict(Counter(dict_eigenvector).most_common(10)))

matplotlib.rcParams['figure.figsize']=[24,8]

def drw(gr_trans,pos,list_a,list_b,measure_name):
  nodes = nx.draw_networkx_nodes(gr_trans,pos,node_size=100,cmap=plt.cm.viridis,node_color=list_a,nodelist=list_b)
  nodes.set_norm(mcolors.SymLogNorm(linthresh=0.01,linscale=1))
  edges = nx.draw_networkx_edges(gr_trans,pos)
  plt.title(measure_name,fontsize=22,fontname='Arial')
  plt.colorbar(nodes)
  plt.axis('off')

plt.subplot(1,3,1)
pos=nx.spring_layout(gr_trans)
list_pos_values = []

for i in nx.degree_centrality(gr_trans).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.degree_centrality(gr_trans).keys():
  list_pos_keys.append(i)
drw(gr_trans,pos,list_pos_values,list_pos_keys,'Degree Centrality')

plt.subplot(1,3,2)
list_pos_values = []

for i in nx.eigenvector_centrality(gr_trans).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.eigenvector_centrality(gr_trans).keys():
  list_pos_keys.append(i)
drw(gr_trans,pos,list_pos_values,list_pos_keys,'Eigenvector Centrality')

plt.subplot(1,3,3)
list_pos_values = []

for i in nx.closeness_centrality(gr_trans).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.closeness_centrality(gr_trans).keys():
  list_pos_keys.append(i)
drw(gr_trans,pos,list_pos_values,list_pos_keys,'Closeness Centrality')

print('-----------------------------------------------------------TARGET---------------------------------------------------------------------------')
adj_matrix_target = target.iloc[1:,1:]
rows, cols = np.where(adj_matrix_target == 1)
edges = zip(rows.tolist(), cols.tolist())
gr_target = nx.Graph()
gr_target.add_edges_from(edges)

dict_degree = nx.degree_centrality(gr_target)
dict_closeness = nx.closeness_centrality(gr_target)
dict_eigenvector = nx.eigenvector_centrality(gr_target)

print('Top 10 values of degree of centrality',dict(Counter(dict_degree).most_common(10)))
#dict(Counter(dict_colseness).most_common(10))
print('Top 10 values of eigenvector centrality',dict(Counter(dict_eigenvector).most_common(10)))

matplotlib.rcParams['figure.figsize']=[24,8]

def drw(gr_target,pos,list_a,list_b,measure_name):
  nodes = nx.draw_networkx_nodes(gr_target,pos,node_size=100,cmap=plt.cm.viridis,node_color=list_a,nodelist=list_b)
  nodes.set_norm(mcolors.SymLogNorm(linthresh=0.01,linscale=1))
  edges = nx.draw_networkx_edges(gr_target,pos)
  plt.title(measure_name,fontsize=22,fontname='Arial')
  plt.colorbar(nodes)
  plt.axis('off')

plt.subplot(1,3,1)
pos=nx.spring_layout(gr_target)
list_pos_values = []

for i in nx.degree_centrality(gr_target).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.degree_centrality(gr_target).keys():
  list_pos_keys.append(i)
drw(gr_target,pos,list_pos_values,list_pos_keys,'Degree Centrality')

plt.subplot(1,3,2)
list_pos_values = []

for i in nx.eigenvector_centrality(gr_target).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.eigenvector_centrality(gr_target).keys():
  list_pos_keys.append(i)
drw(gr_target,pos,list_pos_values,list_pos_keys,'Eigenvector Centrality')

plt.subplot(1,3,3)
list_pos_values = []

for i in nx.closeness_centrality(gr_target).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.closeness_centrality(gr_target).keys():
  list_pos_keys.append(i)
drw(gr_target,pos,list_pos_values,list_pos_keys,'Closeness Centrality')

print('-------------------------------------------------------CHEM_SIM-------------------------------------------------------------------')
adj_matrix_chem = chem_sim.iloc[1:,1:]
rows, cols = np.where(adj_matrix_chem == 1)
edges = zip(rows.tolist(), cols.tolist())
gr_chem = nx.Graph()
gr_chem.add_edges_from(edges)

dict_degree = nx.degree_centrality(gr_chem)
dict_closeness = nx.closeness_centrality(gr_chem)
dict_eigenvector = nx.eigenvector_centrality(gr_chem)

print('Top 10 values of degree of centrality',dict(Counter(dict_degree).most_common(10)))
#dict(Counter(dict_colseness).most_common(10))
print('Top 10 values of eigenvector centrality',dict(Counter(dict_eigenvector).most_common(10)))

matplotlib.rcParams['figure.figsize']=[24,8]

def drw(gr_chem,pos,list_a,list_b,measure_name):
  nodes = nx.draw_networkx_nodes(gr_chem,pos,node_size=100,cmap=plt.cm.viridis,node_color=list_a,nodelist=list_b)
  nodes.set_norm(mcolors.SymLogNorm(linthresh=0.01,linscale=1))
  edges = nx.draw_networkx_edges(gr_chem,pos)
  plt.title(measure_name,fontsize=22,fontname='Arial')
  plt.colorbar(nodes)
  plt.axis('off')

plt.subplot(1,3,1)
pos=nx.spring_layout(gr_chem)
list_pos_values = []

for i in nx.degree_centrality(gr_chem).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.degree_centrality(gr_chem).keys():
  list_pos_keys.append(i)
drw(gr_chem,pos,list_pos_values,list_pos_keys,'Degree Centrality')

plt.subplot(1,3,2)
list_pos_values = []

for i in nx.eigenvector_centrality(gr_chem).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.eigenvector_centrality(gr_chem).keys():
  list_pos_keys.append(i)
drw(gr_chem,pos,list_pos_values,list_pos_keys,'Eigenvector Centrality')

plt.subplot(1,3,3)
list_pos_values = []

for i in nx.closeness_centrality(gr_chem).values():
  list_pos_values.append(i)
  list_pos_keys = []

for i in nx.closeness_centrality(gr_chem).keys():
  list_pos_keys.append(i)
drw(gr_chem,pos,list_pos_values,list_pos_keys,'Closeness Centrality')

"""KNOWING MORE ABOUT THE NETWORK GRAPHS
  --
"""

# Information about the graphs
print('CHEMICAL SIMILARITY INFO: ',nx.info(gr_chem))
print('TARGET INFO: ',nx.info(gr_target))
print('TRANSPORTER INFO: ',nx.info(gr_trans))


# Degree histogram
print('CHEMICAL SIMILARITY ->',nx.degree_histogram(gr_chem))
plt.hist(nx.degree_histogram(gr_chem),bins=3)
plt.show()
print('TARGET ->',nx.degree_histogram(gr_target))
plt.hist(nx.degree_histogram(gr_target),bins=5)
plt.show()
print('TRANSPORTER',nx.degree_histogram(gr_trans))
plt.hist(nx.degree_histogram(gr_trans),bins=3)
plt.show()

"""SPECTRAL CLUSTERING
  --

SPECTRAL CLUSTERING : 
Spectral clustering is a technique with roots in graph theory, where the approach is used to identify communities of nodes in a graph based on the edges connecting them. 
Spectral clustering uses information from the eigenvalues (spectrum) of special matrices built from the graph or the data set.
"""

from sklearn.cluster import SpectralClustering
from sklearn import metrics

print('----------------------------------------TRANSPORTER----------------------------------------')

adjacent_matrix = transporter.iloc[1:,2:]
sc = SpectralClustering(3,affinity = 'precomputed',n_init=100,assign_labels='discretize')
sc.fit(adjacent_matrix)

#clustering results
print('Spectral clustering')
print(sc.labels_)
print('For a better visualization-> Inverted Cluster (permutation)')
print(np.abs(sc.labels_ - 1))

print('-----------------------------------------------TARGET-----------------------------------------------')

adjacent_matrix = target.iloc[1:,2:]
sc = SpectralClustering(3,affinity = 'precomputed',n_init=100,assign_labels='discretize')
sc.fit(adjacent_matrix)

#clustering results
print('Spectral clustering')
print(sc.labels_)
print('For a better visualization-> Inverted Cluster (permutation)')
print(np.abs(sc.labels_ - 1))

print('-----------------------------------------------CHEMICAL SIMILARITY----------------------------------------')

adjacent_matrix = chem_sim.iloc[1:,2:]
sc = SpectralClustering(3,affinity = 'precomputed',n_init=100,assign_labels='discretize')
sc.fit(adjacent_matrix)

#clustering results
print('Spectral clustering')
print(sc.labels_)
print('For a better visualization-> Inverted Cluster (permutation)')
print(np.abs(sc.labels_ - 1))

"""### COMMUNITY DETECTION THROUGH BEST PARTITION ALGORITHM

A community is defined as a subset of nodes within the graph such that connections between the nodes are denser than connections with the rest of the network. This computes the partition(no. of communities) of the graph nodes which maximises the modularity using the Louvain heuristices.

For the Interaction Matrix of the drugs
"""

adj_matrix = interaction_matrix.iloc[0:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())                                       #Edge List
ig = nx.Graph()
ig.add_edges_from(edges)                                                        

ipart = community.best_partition(ig)                                            #The partition, with communities numbered from 0 to number of communities
ivalues = [ipart.get(node) for node in ig.nodes()]

print("There are ", len(ipart), " communities")
plt.rcParams["figure.figsize"] = (30,20)
nx.draw_spring(ig, cmap = plt.get_cmap('jet'),node_color = ivalues,  with_labels=True)

"""For the Chemical Similarity of the drugs"""

adj_matrix = chem_sim.iloc[0:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())                                       #Edge List
cg = nx.Graph()
cg.add_edges_from(edges)

cpart = community.best_partition(cg)                                            #The partition, with communities numbered from 0 to number of communities
cvalues = [cpart.get(node) for node in cg.nodes()]
print("There are ", len(cpart), " communities")

plt.rcParams["figure.figsize"] = (30,20)
nx.draw_spring(cg, cmap = plt.get_cmap('plasma'),node_color = cvalues,  with_labels=True)

"""For the Target of the drugs"""

adj_matrix = target.iloc[0:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())                                       #Edge List
tg = nx.Graph()
tg.add_edges_from(edges)

tpart = community.best_partition(tg)                                            #The partition, with communities numbered from 0 to number of communities
tvalues = [tpart.get(node) for node in tg.nodes()]
print("There are ", len(tpart), " communities")

plt.rcParams["figure.figsize"] = (30,20)
nx.draw_spring(tg, cmap = plt.get_cmap('plasma'),node_color = tvalues, with_labels=True)

"""For the Transporter of the drugs"""

adj_matrix = transporter.iloc[0:,1:]
rows, cols = np.where(adj_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())                                       #Edge List
trg = nx.Graph()
trg.add_edges_from(edges)

trpart = community.best_partition(trg)                                          #The partition, with communities numbered from 0 to number of communities
trvalues = [trpart.get(node) for node in trg.nodes()]
print("There are ", len(trpart), " communities")

plt.rcParams["figure.figsize"] = (30,20)
nx.draw_spring(trg, cmap = plt.get_cmap('jet'),node_color = trvalues, with_labels=True)

"""Spectral clustering(modification in Snehaa's code)"""

from sklearn.cluster import SpectralClustering
from sklearn import metrics

print('----------------------------------------TRANSPORTER----------------------------------------')


adjacent_matrix = transporter.iloc[0:,1:]
print(adjacent_matrix)
sc = SpectralClustering(3,affinity = 'precomputed',n_init=100,assign_labels='discretize')
sc.fit(adjacent_matrix)

rows, cols = np.where(adjacent_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
g = nx.Graph()
g.add_edges_from(edges)

plt.rcParams["figure.figsize"] = (40,20)
nx.draw_spring(G, node_color = sc.labels_, cmap='rainbow',  with_labels=True)
plt.show()

#clustering results
print('Spectral clustering')
print(sc.labels_)
print('For a better visualization-> Inverted Cluster (permutation)')
print(np.abs(sc.labels_ - 1))

print('-----------------------------------------------TARGET-----------------------------------------------')

adjacent_matrix = target.iloc[0:,1:]
sc = SpectralClustering(3,affinity = 'precomputed',n_init=100,assign_labels='discretize')
sc.fit(adjacent_matrix)

rows, cols = np.where(adjacent_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
g = nx.Graph()
g.add_edges_from(edges)

plt.rcParams["figure.figsize"] = (40,20)
nx.draw_spring(G, node_color = sc.labels_, cmap='rainbow',  with_labels=True)
plt.show()

#clustering results
print('Spectral clustering')
print(sc.labels_)
print('For a better visualization-> Inverted Cluster (permutation)')
print(np.abs(sc.labels_ - 1))

print('-----------------------------------------------CHEMICAL SIMILARITY----------------------------------------')

adjacent_matrix = chem_sim.iloc[0:,1:]
sc = SpectralClustering(3,affinity = 'precomputed',n_init=100,assign_labels='discretize')
sc.fit(adjacent_matrix)

rows, cols = np.where(adjacent_matrix == 1)
edges = zip(rows.tolist(), cols.tolist())
g = nx.Graph()
g.add_edges_from(edges)

plt.rcParams["figure.figsize"] = (40,20)
nx.draw_spring(G, node_color = sc.labels_, cmap='rainbow',  with_labels=True)
plt.show()

#clustering results
print('Spectral clustering')
print(sc.labels_)
print('For a better visualization-> Inverted Cluster (permutation)')
print(np.abs(sc.labels_ - 1))

"""For more info about spectral clustering :https://towardsdatascience.com/spectral-clustering-aba2640c0d5b

This package is presented by :

Janet Macrina.G  18PD13
    Majella Yuktha.B 18PD17
    Snehaa.S         18PD36
"""